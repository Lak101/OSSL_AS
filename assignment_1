Q2 . 
#include <stdio.h>
#include <stdlib.h>

int main() {
    int n, i;
    float *arr;
    float sum = 0.0, average;

    printf("Enter the number of elements: ");
    scanf("%d", &n);


    arr = (float *)malloc(n * sizeof(float));
    if (arr == NULL) {
        printf("Memory allocation failed \n");
        return 1;
    }
    printf("Enter %d elements:\n", n);
    for (i = 0; i < n; i++) {
        scanf("%f", &arr[i]);
        sum += arr[i];
    }

    average = sum / n;

    printf("Average of the elements = %.2f\n", average);
    free(arr);

    return 0;
}
-----------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Q3
#include <stdio.h>

int main() {
    char str[100];
    int i, length = 0;

    printf("Enter a string: ");
    gets(str);

    while (str[length] != '\0') {
        length++;
    }

    printf("Reversed string: ");
    for (i = length - 1; i >= 0; i--) {
        printf("%c", str[i]);
    }
    printf("\n");

    return 0;
}
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
Q4.
I extracted a simple open-source to-do list application from GitHub and reverse engineered it to understand its core functionality and structure. By analyzing the source code, I identified how the app manages tasks, including creating, updating, and deleting to-do items. The app’s user interface, data storage method, and event handling were examined to see how user interactions translate into data changes. This process gave me insight into the app’s architecture, including how state is maintained and how the components communicate. Overall, this exercise helped me understand the practical implementation of a basic CRUD (Create, Read, Update, Delete) application and reinforced key programming concepts used in building interactive, user-driven software.
-------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------
